
Project Chimera: A Design and Implementation Bible for a Modular, Procedural TBS-RPG in Godot 4.5


Section 1: Core Architectural Pillars: A Data-Oriented Foundation

This section establishes the foundational technical architecture for Project Chimera. The design philosophy detailed herein is paramount; it prioritizes a strict separation of data from logic to manage the immense complexity inherent in a highly modular, procedural game. The architectural decisions outlined below are not merely implementation details but the very bedrock upon which the game's capacity for emergent gameplay will be built. Every subsequent system, from character generation to narrative progression, will be a direct consequence of this foundation.

1.1 The Data-First Mandate: Composition Over Inheritance

The central design goal of Project Chimera is to foster emergent outcomes through radical modularity. To achieve this, the architecture must reject traditional, rigid class hierarchies in favor of a more fluid, data-centric model. The principle of composition over inheritance will be strictly enforced across all game systems. This philosophy aligns perfectly with Godot's engine design, which encourages the use of nodes and scenes as compositional building blocks rather than relying on deep, complex inheritance chains.1
Instead of creating specific, monolithic classes for every type of game object (e.g., a Goblin class inheriting from a Monster class, which inherits from an Enemy class), all entities in the game world will be defined by the data components they possess. A goblin is not a "goblin" because of its class type; it is a "goblin" because it possesses a specific combination of StatsComponent, AIBehaviorComponent, and AppearanceComponent resources that collectively describe its attributes and behavior.
This data-oriented approach offers several critical advantages for a project of this nature. Firstly, it prevents the inevitable explosion of class hierarchies that occurs when trying to represent a wide variety of unique entities. Secondly, and more importantly, it makes the procedural generation of novel entity types a trivial matter. A new creature is not created by writing a new script, but by algorithmically assembling a new combination of existing data components. This flexibility is the key to creating a world that can surprise both the player and its designers.
The implementation of this principle will be straightforward but disciplined. All game entities—be they player characters, monsters, NPCs, or even interactive objects—will be instances of a single, base Entity scene. This scene acts as a generic container. Its specific identity and functionality are determined at runtime by the collection of Resource files (our data components) that are attached to it. This design ensures that any system can interact with any entity on a common data level, which is the primary catalyst for emergent interactions.

1.2 Architecture Selection: A Hybrid ECS-Resource Approach

To effectively implement a data-oriented design in Godot 4, a core architectural pattern must be selected. The primary contenders are the engine's native Custom Resource system and a more formal Entity-Component-System (ECS) framework. Each offers distinct advantages and trade-offs, and the optimal solution for Project Chimera lies in a hybrid model that synthesizes the strengths of both.
Custom Resources (.tres files) are a cornerstone of data management in Godot. They are scriptable objects that extend the Resource class and serve as powerful, self-contained data containers. Their primary advantage is their seamless integration with the Godot editor. Designers can create, view, and modify these data assets directly in the Inspector panel, providing an intuitive and efficient workflow for content creation. Resources are inherently serializable, version-control friendly (when saved as text-based .tres files), and can even encapsulate their own methods and signals, allowing for sophisticated data structures.2 However, a project architecture that relies exclusively on resources for both data and logic can become problematic. Refactoring variable names in a resource script can lead to data loss across all instances of that resource, posing a significant long-term maintenance risk. Furthermore, over-reliance on resources can lead to a tangled web of dependencies that undermines modularity.3
Entity-Component-System (ECS) is an architectural pattern that enforces a strict separation between data (Components), identity (Entities), and logic (Systems). Frameworks available for Godot, such as GECS (Godot Entity Component System), provide a structured way to implement this pattern. In a pure ECS model, Components are simple data containers, Entities are unique identifiers that group components, and Systems contain all the logic, operating on collections of entities that possess a specific set of components.5 This pattern is renowned for its performance benefits, particularly when processing thousands of entities, as it promotes data locality and cache-friendly operations.7 Systems query for entities based on their components (e.g., "process all entities with
PositionComponent and VelocityComponent"), which results in highly decoupled and maintainable code.6
For Project Chimera, the recommended architecture is a hybrid model that marries the designer-friendly workflow of Custom Resources with the clean, scalable logic of an ECS-like structure.
* Data (Components): All data-only components, such as StatsComponent, InventoryComponent, or SkillComponent, will be implemented as Custom Resources. These will be GDScript files that extend the Resource class. This approach empowers designers to use the Godot Inspector as their primary tool for creating and balancing the archetypes for characters, items, skills, and other game elements.
* Logic (Systems): All game logic will be encapsulated within Systems, which will be implemented as standard Godot Nodes. These System nodes will be children of a central World node, as prescribed by the GECS pattern.6 The main game loop will not be in individual objects but will instead iterate through the active Systems (e.g.,
MovementSystem, CombatSystem, AISystem). Each System, in turn, will query the game world for entities that possess the necessary component resources and then execute its logic upon them.
This hybrid architecture resolves the fundamental tension between a programmer-centric ECS workflow and a designer-centric Resource-based workflow. It creates a symbiotic development process where designers are empowered to create and balance a vast library of data components using the intuitive tools of the Godot editor, while programmers are free to build robust, decoupled, and performant logic systems that operate on that data. This structure provides the organizational clarity of ECS while retaining the rapid iteration capabilities of Godot's native resource system, making it the ideal foundation for a project defined by modularity and procedural generation.

1.3 The Global Event Bus: Decoupling the Modules

In a game with dozens of interconnected procedural systems, direct communication between modules is a direct path to unmaintainable "spaghetti code." If the QuestSystem needs to directly call a function within the InventorySystem, which in turn needs to update the UISystem, these modules become tightly coupled. Any change to one system risks breaking the others. This brittleness is antithetical to the project's goal of modularity.
To solve this, the architecture will employ a global Event Bus. This will be implemented as an autoloaded Godot singleton, a script named EventBus that is globally accessible from any other script in the project. This node will serve as a central, anonymous dispatcher for all significant game-wide events. Instead of calling each other directly, systems will emit signals on the EventBus, and any other interested systems can subscribe to those signals without needing to know who sent them.1
Consider the following example flow when a monster is defeated in combat:
1. The CombatSystem concludes its calculations and determines that a specific monster entity has been defeated.
2. Instead of directly calling other systems, it prepares a data packet (e.g., a dictionary containing the defeated monster's data) and emits a signal on the central bus: EventBus.emit_signal("entity_killed", monster_data).
3. The QuestSystem, which has previously connected its _on_entity_killed method to this signal, receives the broadcast. It checks the monster_data to see if this kill satisfies any active quest objectives and updates its internal state accordingly.
4. The LootSystem is also subscribed to the entity_killed signal. It uses the monster_data (which might contain information about the monster's level and type) to trigger its procedural loot generation algorithm and spawn the appropriate items in the world.
5. Simultaneously, the MetaNarrativeSystem receives the same signal. It logs this event to a persistent data file, tracking the player's actions to influence future "World Runs."

For a quick visual refresher while reviewing this handshake, consult `devdocs/diagrams/event_flow_sequence.svg`. The sequence diagram illustrates the DebugSystem telemetry loop alongside the combat defeat broadcast, highlighting how the EventBus fans out payloads to quest, loot, analytics, and debugging modules without hard references.
This pattern formalizes Godot's built-in signal system into a robust, game-wide communication architecture.10 The
EventBus becomes the single, well-defined point of contact for all inter-system communication. Systems remain completely decoupled; the CombatSystem has no knowledge of quests or loot, it only knows that it must report when an entity is killed. This decoupling is absolutely essential for building a complex, emergent system where new modules can be added or existing ones modified with minimal risk of cascading failures.

1.4 The Module and Asset Registries

To manage the vast libraries of both handcrafted content and procedural generation logic, the architecture will utilize two additional autoloaded singletons: the AssetRegistry and the ModuleRegistry. These registries are responsible for loading and providing centralized access to all the game's building blocks, ensuring efficient and organized data management.
The AssetRegistry will serve as the central repository for all handcrafted data assets. On game startup, this singleton will systematically scan specified directories within the project (e.g., res://assets/items/, res://assets/quests/handmade/, res://assets/entity_archetypes/). It will load every .tres resource file it finds into memory, storing them in dictionaries keyed by a unique identifier (such as their filename or a dedicated ID property within the resource). This pre-loading mechanism provides instantaneous, memory-efficient access to any handcrafted asset from any system in the game. It avoids the performance overhead and code clutter of repeatedly calling load() or preload() throughout the codebase.
The ModuleRegistry will perform a similar function but for procedural logic modules. It will register all the different generator "Systems" that are available, such as DungeonMapGenerator, LegendaryWeaponGenerator, or HeistQuestGenerator. This allows other high-level systems, like the Narrative Designer, to request the generation of content abstractly. Instead of needing a direct reference to a specific generator node, the Narrative Designer can simply call a function like ModuleRegistry.generate("world_map", seed, parameters). The ModuleRegistry is then responsible for finding the correct module and executing its generation logic. This further decouples the high-level "director" systems from the low-level "creator" systems, enhancing modularity and making it easy to add new types of procedural generators to the game over time.
Systems resolve these generators through accessor helpers such as
`ModuleRegistry.get_module("world_map")`, optionally guarded by
`ModuleRegistry.has_module("world_map")`, rather than touching the
singleton's internal dictionaries directly.

Section 2: The Universal Entity: A Blueprint for All Beings

The foundation of emergent gameplay lies in the interaction of simple, universal rules. To facilitate this, Project Chimera will adopt a universal data structure for every single actor and interactive object in the game world. This "Universal Entity" blueprint ensures that all game systems—from Combat and AI to Dialogue and Quests—can interact with any entity through a common interface. This design choice is the primary mechanism by which unplanned, emergent interactions will occur. When a monster, an NPC, a player character, and a destructible piece of scenery all share a common data structure for health, they can all be affected by the same area-of-effect spell without any special-case coding.

2.1 The EntityData Resource: The Digital DNA

The cornerstone of the Universal Entity design is a master Custom Resource script named EntityData.gd. This script will serve as the base template from which all character, monster, and object archetypes are derived. It is not intended to be used directly but rather to define the common, non-negotiable data fields that every entity in the game world must possess.
A specific entity, such as a "Goblin Archer," will be represented in the project as an EntityData.tres file. Within this resource file, its properties would be set accordingly: display_name would be "Goblin Archer," entity_type would be MONSTER, and its components dictionary would be populated with references to other, more specialized resource files like GoblinArcherStats.tres, SkirmisherAI.tres, and GoblinLootTable.tres. This structure acts as the digital DNA for the entity, providing a complete, self-contained definition of its properties and potential behaviors.
The establishment of this universal data structure is the most critical step in enabling emergence. It creates a "lingua franca" for all game systems. A procedurally generated "Rockslide" trap, for instance, does not need custom logic to handle different target types. Its logic is simple: apply damage to any entity within its area of effect that possesses a StatsComponent with a health value. Because players, monsters, and even certain environmental objects all conform to the EntityData standard and can possess a StatsComponent, they are all valid targets for the trap's logic. This principle, when extrapolated across hundreds of skills, items, and environmental interactions, generates the vast combinatorial possibility space required for truly emergent gameplay.

Table 2.1: EntityData Base Resource Definition

The following table defines the core properties of the EntityData.gd resource. This structure is the single most important data contract in the project. It dictates the fundamental way in which all game systems will query and interact with the actors in the world.

---------------------------------------------
| |Property Name | |Data Type | |Description | |Rationale & Source Links |
---------------------------------------------
| |entity_id | |String | |A unique identifier for this specific entity instance, which remains persistent within a single World Run. | |Essential for saving, loading, and tracking specific entities for quest objectives and narrative state. |
---------------------------------------------
| |display_name | |String | |The player-facing, in-game name of the entity (e.g., "Grak the Fierce," "Town Guard"). | |Provides the necessary information for user interface elements and dialogue. |
---------------------------------------------
| |entity_type | |Enum | |A broad category classification: PLAYER, NPC, MONSTER, WILDLIFE, OBJECT. | |Allows high-level systems to quickly filter for general types of entities without needing to inspect their components. |
---------------------------------------------
| |archetype_id | |String | |The unique ID that links to the base archetype resource used for this entity's procedural generation. | |Crucial for informing AI behavior selection and providing context for other procedural systems.12 |
---------------------------------------------
| |components | |Dictionary | |A dictionary holding references to all attached Component Resource files. The dictionary is keyed by the component's type (e.g., "stats", "inventory"). | |This is the core of the modular, compositional design, allowing any entity to be composed of any combination of data blocks.1 |

2.2 Component Design: Modular Data Blocks

Following the hybrid ECS-Resource architecture, Components are the modular data blocks that define an entity's attributes. Each component is a small, self-contained Custom Resource file that manages a specific domain of data. An EntityData resource is, in essence, a manifest that lists and provides references to all the component resources that constitute a complete entity. This compositional approach allows for maximum flexibility and reuse of data structures.
The following core components will form the basis of most entities in the game:
* StatsComponent.tres: This is the most fundamental component, holding all primary combat and utility statistics. This includes attributes like Health Points (HP), Action Points (AP), Strength, Dexterity, Intelligence, Speed, as well as arrays or dictionaries for resistances and vulnerabilities to various damage types.
* SkillComponent.tres: This component contains an array of references to Skill.tres resources. Each Skill.tres is another resource that defines a single usable ability, including its AP cost, targeting rules, effects, and animations. This component effectively defines what an entity can do.
* TraitComponent.tres: This component holds an array of references to Trait.tres resources. Traits are passive modifiers that affect an entity's stats, grant special abilities, or provide flags for the AI and narrative systems. Examples include "Cowardly" (which the AI system would use to favor fleeing behavior), "Fire-Attuned" (which the combat system might use to grant a bonus to fire damage), or "Merchant" (which the dialogue system would use to open a trade interface).
* InventoryComponent.tres: This component manages a collection of item resources. For player characters, this is their backpack. For NPCs, this can represent their shop inventory or personal belongings. For monsters, this component can define their potential loot drops, which the LootSystem will use upon their defeat.
* AIBehaviorComponent.tres: This crucial component dictates an entity's behavior when not controlled by the player. It will contain a reference to a specific behavior script or a pre-configured Behavior Tree resource, allowing for a wide range of AI personalities from simple "attack-on-sight" logic to complex, goal-oriented plans.
* FactionComponent.tres: This defines the entity's allegiance. It will hold an ID for its primary faction and a dictionary of reputation scores with all other major factions in the world. This data is critical for determining social interactions and enemy targeting.
* QuestStateComponent.tres: This component acts as an entity's personal quest log. For NPCs, it tracks the status of quests they can offer the player (e.g., AVAILABLE, IN_PROGRESS, COMPLETED). For any entity, it can track their specific role in any active quests (e.g., QUEST_TARGET, QUEST_ESCORT_VIP).

2.3 Procedural Character Generation

A core feature of Project Chimera is the ability to algorithmically generate unique and coherent characters, NPCs, and monsters. This process must blend randomness with a set of guiding constraints to ensure the generated entities are not only varied but also mechanically functional and thematically consistent.14 The generation will follow a multi-stage pipeline managed by a dedicated
CharacterGenerator module.
1. Archetype Selection: The process begins by selecting a base archetype from a handcrafted library of Archetype.tres resources. An archetype (e.g., "Brute," "Mage," "Skirmisher," "Merchant") serves as a template, defining statistical leanings, potential skill pools, and valid trait combinations. This provides the initial set of constraints for the generator.
2. Stat Allocation: To avoid generating useless characters, the system will use a constrained point-buy method rather than pure random rolls. For example, instead of rolling each stat on a D20, the character is given a total number of points to distribute. The selected archetype then biases this distribution; a "Brute" archetype will have a higher probability of allocating points to Strength and Constitution, while a "Mage" will favor Intelligence and Willpower. This ensures a baseline of viability while still allowing for random variation.16
3. Skill and Trait Assignment: The generator selects a number of skills and traits from data pools associated with the chosen archetype. A "Brute" might draw from a pool of melee weapon skills and traits like "Tough" or "Aggressive." To add flavor and create opportunities for emergent synergies, the generator will also select one or two "hobby" skills or traits from a global pool, which could result in a Brute who is also a surprisingly good "Cook" or has the "Animal Lover" trait.12
4. Backstory and Flavor Text Generation: Once the mechanical aspects of the character are defined, the system generates a brief textual biography to give them personality. This is a prime candidate for the planned LLM integration. The CharacterGenerator will assemble a structured summary of the character's generated data, such as {"Archetype": "Mage", "Skills": ["Fireball", "Cooking"], "Traits":}. This structured data is then used to engineer a prompt for the local LLM, such as: "Write a short, two-sentence backstory for a brave but clumsy mage who is also a surprisingly skilled cook." The LLM's role is to translate the structured data into natural-sounding, flavorful text, adding a layer of personality that would be difficult to achieve with simple string concatenation.12
5. Component Assembly and Finalization: In the final stage, the generator uses all the generated data to create and save a new set of component .tres files (e.g., a unique StatsComponent.tres, SkillComponent.tres, etc.). These newly created component resources are then linked into a master EntityData.tres resource, which represents the complete, ready-to-spawn procedural character.

Section 3: The Procedural World Engine

This section details the design and implementation of the systems responsible for creating the game's dynamic canvas: the "World Run." The process is architecturally divided into two distinct phases: first, the generation of the abstract, structural world map, and second, the intelligent population of that map with narrative content, encounters, and objectives. This separation is critical for achieving a high degree of replayability while maintaining narrative coherence.

3.1 World Run Generation Framework

A "World Run" constitutes a single, self-contained gameplay session. Each run features a unique, procedurally generated world, a distinct main quest, and a specific set of rules and constraints. The meta-progression system is built around the player's ability to influence the parameters of these runs over time.
Before a run begins, the player can adjust its generation using a set of parameters, many of which are unlocked through meta-progression. This gives the player a degree of agency over their experience and serves as a core reward mechanism. These parameters include:
* World Seed: A string of text or numbers that serves as the initial value for the random number generator. The same seed will always produce the exact same World Run, allowing players to replay, master, or share specific world layouts.14
* Map Modifiers: High-level parameters that control the physical structure of the world map. Examples include Size (Small, Medium, Large), which affects the number of nodes; Density (Sparse, Dense), which affects the number of connections between nodes; and Shape (e.g., Archipelago, Single Continent, Mountainous), which influences the application of biome layers.
* Faction Modifiers: Parameters that influence the socio-political landscape of the world. Examples include "Warring Factions," which increases the number of hostile encounters and faction-based quests, or "Trade Boom," which increases the number of merchant nodes and the availability of rare items.
* Constraint Modifiers: Rules that define the run's difficulty and limitations. This includes the Turn Limit (the total number of moves the player can make on the world map), the Save Limit (the number of times the player can save their progress during the run), and the starting Team Size.
The output of this generation phase is a master WorldState resource. This object is the central state container for the entire run, storing the initial seed, all selected parameters, and the fully generated map graph. It serves as the single source of truth for the duration of the gameplay session.

3.2 Graph-Based World Map Generation

For a non-linear, strategic experience, a graph-based map is the ideal data structure. In this model, nodes represent distinct locations, points of interest, or potential encounters, while edges represent the travel paths connecting them. This approach is significantly more flexible and allows for more deliberate narrative and gameplay design than a simple grid-based generation method (e.g., a heightmap generated with Perlin noise).18 A graph allows for precise control over connectivity, choke points, and the logical flow of the game world.
The world map generation will follow a layered, multi-stage pipeline:
1. Point Distribution: The process begins by scattering a set of points across the desired map area. To avoid unnatural clustering and create a more organic layout, this will be done using a Poisson Disk Sampling algorithm, which ensures that no two points are closer than a specified minimum distance. These points will become the locations of our map nodes.
2. Graph Creation: From this set of points, the system will compute a Voronoi diagram. This partitions the map into a series of polygonal cells, where each cell contains one of the initial points. The dual of this diagram, the Delaunay triangulation, connects the original points into a mesh of triangles. By combining these two structures, we can create a robust graph where the centers of the Voronoi cells are our map nodes, and the edges of the Delaunay triangulation represent potential travel paths between them.20
3. Path Pruning and Refinement: The initial graph generated by the Delaunay triangulation is typically fully connected, which is not ideal for interesting gameplay. The next step is to prune this graph to create a more strategic layout. A percentage of edges will be randomly removed. After each removal, a connectivity check (using an algorithm like Breadth-First Search or a Union-Find data structure) is performed to ensure that no node becomes completely isolated from the main graph. A key goal during this phase is to ensure the existence of a reasonable number of loops in the graph. A map with too few loops forces excessive backtracking, which can be tedious for the player, while a map with too many loops can lack strategic choke points.19
4. Attribute Layering: Once the final graph structure is established, the system applies several layers of coherent noise (such as Perlin or Simplex noise) across the map to assign geographical and environmental attributes to the nodes.21
	* An Elevation Layer can be used to assign tags like Mountain, Plains, or Coastline to nodes.
	* Temperature and Humidity Layers can be generated and combined to determine a biome for each node or region, resulting in tags like Desert, Forest, Tundra, or Swamp.21

These attributes are not merely cosmetic; they are critical data points that will be used by the Narrative Designer module to determine the types of encounters, resources, environmental hazards, and quests that can appear at each node.

3.3 The Narrative Designer Module

The Narrative Designer is a sophisticated AI system that acts as an intelligent "Dungeon Master." Its purpose is to take the raw, abstract map graph and populate it with content in a way that creates a coherent, playable, and compelling narrative experience. This separation of structural generation (the graph) from content population (the Narrative Designer) is a cornerstone of the architecture. It allows the same graph generation algorithm to produce maps for vastly different scenarios simply by providing the Narrative Designer with a different set of rules and content.
The Narrative Designer's process is a sequence of deliberate placement and distribution steps:
1. Main Quest Placement: The module's first and most important task is to place the key locations for the procedurally generated main quest. For a quest like "Find the Artifact of Power," it will select a suitable starting node for the player, a final objective node (e.g., a node tagged as a Boss_Dungeon), and several intermediate nodes for clues or sub-objectives. It uses graph traversal algorithms (like Dijkstra's or A*) to ensure these key locations are a reasonable distance apart, creating a sense of journey and progression.
2. Landmark and Town Placement: To provide narrative anchors and safe havens for the player, the designer places a small number of handcrafted "landmark" nodes (e.g., the "City of Brass," the "Whispering Forest") and generic town/settlement nodes onto the graph. These are drawn from the AssetRegistry and are placed in biome-appropriate locations.
3. Encounter Distribution: The remaining empty nodes are filled with a mix of combat encounters, non-combat events, and resource points. The type of content placed is heavily influenced by the node's attributes. A node with the Forest tag is more likely to receive a "Wolf Pack" or "Bandit Ambush" encounter, while a Mountain node might get a "Roc Nest" or "Mine Entrance." The difficulty of these encounters is scaled based on their graph distance from the player's starting node, creating a natural difficulty curve.
4. Path Gating: To create more complex, non-linear progression, the designer can implement a "lock-and-key" system on the graph's edges. For example, an edge connecting two nodes might be blocked by a "Chasm" encounter. To pass, the player must first acquire a "Rope" item. The designer can then place a sub-quest at another node on the map that rewards the player with this "Rope." This creates logical dependencies and branching paths, a core concept in AI planning-based quest generation.22
5. Validation Pass: Before finalizing the world, the module runs a validation pass to ensure its integrity. It confirms that the main quest is completable (i.e., there is a valid path from the start to the end) and that the entire map is navigable and free of any game-breaking dead ends.
This layered approach, separating the geometric creation of the map from the semantic population of its content, is what prevents the game from feeling like "procedural oatmeal"—a term for procedurally generated content that is infinitely varied but perceptually uniform.23 The Narrative Designer's rule-based intelligence is what imbues the procedurally generated world with purpose and a handcrafted feel.

Section 4: The Emergent Narrative and Quest System

This section outlines the architecture for the systems that generate the game's core interactive content: the quests and narratives that drive player motivation and action. The design philosophy moves beyond simple, static quest templates to create a dynamic system capable of generating multi-stage, branching narratives with meaningful consequences. This is achieved by deconstructing quests into fundamental building blocks and using an AI planning-inspired system to assemble them into coherent wholes. Furthermore, a meta-narrative engine will track player actions across multiple runs to create a persistent, evolving story.

4.1 Modular Quest Primitives: The Task Resource

To achieve true procedural quest generation, quests must be broken down into their smallest logical, verifiable units. In this architecture, these units are called Tasks. Each Task is implemented as a Custom Resource file (Task.tres) that represents a single, atomic objective. This modular approach allows for the flexible combination of simple objectives into complex quest structures.22
A library of Task resource types will be created, each with its own specific data and a corresponding logic handler in the QuestSystem to check for its completion. The core Task types will include:
* GoTo_Task.tres: Contains a target map node ID. The task is complete when the player enters that node.
* Kill_Task.tres: Contains a target entity_id (for a specific character) or an entity_archetype_id (for a type of monster). The task is completed when the QuestSystem receives an entity_killed event from the EventBus that matches the target.
* Fetch_Task.tres: Contains a target item_id. The task is complete when an item with the matching ID is present in the player's InventoryComponent.
* GiveItem_Task.tres: Contains a target NPC_id and a target item_id. The task is completed when the player initiates a dialogue with the target NPC and chooses the "give item" option with the correct item.
* TalkTo_Task.tres: Contains a target NPC_id. The task is complete upon initiating a dialogue with that NPC.
* Interact_Task.tres: Contains an ID for a specific interactive object within a scene/node. The task is completed when the player interacts with that object.
* Composite_Task.tres: This is a special container task that holds an array of other Task resources. It also has a logical operator (AND or OR). For an AND task, all sub-tasks must be completed. For an OR task, completing any one of the sub-tasks is sufficient. This composite primitive is the key to creating branching questlines and offering player choice.

4.2 Hierarchical Quest Generation: The QuestPlanner

To assemble these Task primitives into coherent and logical quests, the architecture will feature a QuestPlanner module. This system is inspired by classical AI planning techniques, where a problem is solved by taking a high-level goal and recursively breaking it down into a sequence of executable actions.22 The
QuestPlanner will use a library of predefined "quest patterns" to build quest structures dynamically based on the current WorldState.
The generation process for a single quest proceeds as follows:
1. Goal Selection: The process is initiated when another system, typically the NarrativeDesigner, requests a quest with a high-level, abstract goal. For example: (GOAL: Defeat_Warlord). The goal is also supplied with context, such as the Warlord's entity ID and the general region of the map.
2. Precondition Resolution: The QuestPlanner consults its library of patterns and recognizes that the action Defeat_Warlord has a critical precondition: (PRECONDITION: Know_Warlord_Location). The player cannot kill the Warlord if they do not know where he is. The planner generates a Kill_Task for the Warlord but marks it as inactive or locked until its precondition is met.
3. Recursive Planning and Subgoal Creation: The planner now sets a new, intermediate subgoal: (GOAL: Know_Warlord_Location). It again searches its pattern library for ways to achieve this goal. It might find several patterns, such as: "To learn a location, one can talk to an informant," "To learn a location, one can find a map," or "To learn a location, one can interrogate a subordinate."
4. Branching and World State Grounding: The planner selects one or more of these patterns and attempts to "ground" them in the current WorldState. It might find a suitable NPC tagged as an "Informant" in a nearby town and generate a TalkTo_Task for that NPC. Alternatively, it could identify an enemy outpost on the map and generate a Fetch_Task for a "Battle Plans" item located there. If it grounds multiple valid patterns, it can create a Composite_Task with an OR condition, presenting the player with a meaningful choice on how to proceed.
5. Quest Assembly: The planner continues this recursive process, breaking down goals into subgoals and grounding them as Tasks, until it reaches primitive tasks that have no unfulfilled preconditions (e.g., a GoTo_Task to the town where the informant lives). The final output of this process is a Quest.tres resource, which is a hierarchical tree of interconnected Task resources representing the complete, multi-stage quest.

4.3 The Meta-Narrative Engine: Weaving Runs Together

The Meta-Narrative Engine is designed to create a persistent, evolving story that connects what would otherwise be isolated World Runs. The core principle is that the player's actions and the outcomes of one run should have tangible, observable consequences in subsequent runs, creating a sense of a continuous, overarching narrative.24
This is achieved through a persistent save object, the MetaState, which is stored in the meta_save.dat file and loaded into a singleton at the start of the game. This object acts as the game's long-term memory, recording the most significant events of the player's entire journey. The MetaState object will contain:
* World Facts: A list of major, world-altering events that have occurred across all runs. These are stored as simple, declarative strings, such as ``.
* Character Fates: A dictionary tracking the status of all persistent, named characters. For example: {"Astra": "Alive, Level 10", "Boris": "Deceased, Run 4"}.
* Player Legacy: Global statistics or reputation scores that reflect the player's overall playstyle (e.g., "Honorable," "Ruthless").
* Unlocked Content: A list of all content the player has unlocked for meta-progression, which is used by the World Run Generation Framework.
This MetaState object directly influences the generation of new World Runs. During the map population phase, the NarrativeDesigner and QuestPlanner will query the MetaState to add context and continuity to the new world:
* Continuity Example: If the MetaState contains the fact Warlord_Krox_Defeated_In_Run_4, the NarrativeDesigner's rules will prevent it from placing Warlord Krox in the new world. Instead, a different rule might be triggered to spawn a "Cult of Krox" faction seeking revenge, or place Krox's "legendary axe" as a discoverable artifact.
* Responsive Narrative Example: If the MetaState shows that the player has repeatedly failed runs due to poison-based enemies, the MetaNarrativeEngine can flag this pattern. In the next run, it can instruct the QuestPlanner to generate a special, high-priority quest chain to "Find the Legendary Serpent's Fang Antidote," directly responding to the player's personal struggles.
* Dialogue Context Example: An NPC's dialogue generation can be informed by the MetaState. A blacksmith might have a line of dialogue that only triggers if the Warlord_Krox_Defeated fact is present: "I heard about your victory over Krox in the last cycle. The whole realm owes you a debt."
This creates a powerful feedback loop: Player actions in a run lead to a specific outcome, which updates the MetaState. The MetaState then influences the generation of the next run, which presents the player with a new set of challenges and narrative threads based on their own history. This loop is the procedural meta-narrative. It is not a pre-written story but a system that generates a continuous, personalized history that is unique to each player's journey.

Section 5: Core Gameplay Loops and Systems

This section details the design of the moment-to-moment gameplay systems that are activated when the player enters a map node and triggers an encounter. The architecture emphasizes a unified approach, using a single, robust manager to handle all forms of turn-based interaction. It also covers the procedural generation of rewards and the carefully constrained integration of a local Large Language Model (LLM) to enhance narrative flavor.

5.1 The Turn-Based Interaction Manager

To maintain modularity and avoid code duplication, a single, unified system will be responsible for managing all turn-based encounters. Whether the player is engaged in tactical combat, a complex dialogue negotiation with multiple parties, or a timed environmental puzzle, the core turn-based logic will be handled by the Interaction Manager.
The heart of this manager will be a Finite State Machine (FSM), a well-established pattern for managing discrete states in game development.26 The primary states of the FSM will include:
* START_ENCOUNTER: Initializes the encounter, gathers all participating entities, and prepares the turn queue.
* CALCULATE_TURN_ORDER: Sorts the list of participants to create the turn queue. By default, this is based on each entity's Speed statistic, from highest to lowest.26
* AWAITING_INPUT: The state for the active entity's turn. For player characters, it waits for player commands. For AI entities, it triggers their behavior logic.
* PROCESS_ACTION: An action has been selected. This state is responsible for resolving the action's effects (e.g., calculating damage, applying status effects, updating quest states).
* END_TURN: The current entity's turn is over. The manager advances to the next entity in the queue. If the queue is empty, it transitions back to CALCULATE_TURN_ORDER for the next round.
* CHECK_END_CONDITIONS: After each action or turn, this state checks if the encounter's end conditions (e.g., all enemies defeated, dialogue goal reached, puzzle solved) have been met.
* END_ENCOUNTER: The encounter is over. This state handles cleanup, reward distribution, and transitioning the game back to the world map view.
All actions within this system are governed by Action Points (AP). At the start of its turn, each entity receives a number of AP determined by its StatsComponent. Every action, from moving one grid space to using a complex skill, has a defined AP cost. An entity can perform multiple actions in its turn as long as it has sufficient AP.
A critical architectural detail is that actions are not resolved instantly by the entity that performs them. When a player or AI chooses an action (e.g., "Cast Fireball at Target X"), it creates an Action data object and submits it to the Interaction Manager's queue. The PROCESS_ACTION state is then responsible for executing this action, calculating all its consequences, and updating the state of all affected entities. This centralized, asynchronous handling is crucial for managing complex interactions, such as an attack that chains to multiple targets or an effect that triggers a series of counter-attacks. The system will rely heavily on Godot's signals to manage the timing of animations, visual effects, and sound, ensuring that the game waits for an animation to complete before processing the next step in the turn order.28

5.2 Procedural Item and Artifact Generation

The generation of loot and rewards is a core driver of player progression in an RPG. To ensure variety and replayability, Project Chimera will employ a sophisticated, rule-based randomized algorithm for item generation, based on established practices in the genre.29 This system will be capable of creating a near-infinite variety of equipment by combining base items with a vast library of magical affixes.
The item generation process, managed by the LootSystem, follows these steps:
1. Base Item Selection: The process begins by selecting a base item template from the AssetRegistry. These templates (e.g., IronSword.tres, LeatherArmor.tres) are handcrafted Resource files that define the item's fundamental properties: its type (weapon, armor, etc.), equipment slot, base damage or defense values, and visual appearance.
2. Quality Roll: The system then determines the item's quality tier (e.g., Common, Magic, Rare, Unique). This is a weighted random roll, with probabilities that can be modified by the player character's "Quality Find" statistic. The formulas for this will incorporate diminishing returns to prevent the stat from becoming overpowered.29
3. Affix/Modifier Application: Based on the rolled quality, the item is assigned a number of magical affixes. These affixes are themselves small Affix.tres resources that define a specific bonus (e.g., "+ Strength," "Adds Fire Damage," "Resists Poison").
	* Magic quality items might receive 1-2 affixes.
	* Rare quality items might receive 3-4 affixes.
	* Unique quality items are special. They may have 5-6 affixes and are often assigned a unique, handcrafted Trait resource that grants a special, game-altering ability not available through normal affixes.
4. Stat Value Calculation: The numerical values of the applied affixes (e.g., the "X" in "+X Strength") are randomly rolled. The range of this roll is determined by the item's level, which is typically based on the level of the monster that dropped it or the difficulty of the area in which it was found. This ensures that loot scales appropriately with the player's progress.29
5. Finalization and Instantiation: The system assembles all of this generated data to create a new, unique item resource in memory. This new resource, with its base type, quality, affixes, and rolled stat values, is then added to the player's InventoryComponent or spawned as loot in the game world.

5.3 The LLM Dialogue Enhancer

The integration of a Large Language Model (LLM) is intended to add dynamic, context-aware flavor and personality to in-game text, particularly dialogue and descriptions. The architectural approach is critical: the LLM will be used as a powerful text-enhancement tool, but it will never be responsible for critical game logic, quest information, or branching choices. This ensures that the game remains deterministic, performant, and free from the risk of LLM "hallucinations" breaking the gameplay experience.
The technical implementation will leverage the godot-llm Godot addon, which provides the necessary nodes and API for interacting with locally run LLMs in the GGUF format.30 The
GDLlama node will be used for asynchronous text generation to prevent the game from freezing while waiting for the LLM's response.
The core of this system is the Data-to-Prompt Pipeline, which translates the game's structured state into a carefully engineered prompt for the LLM:
1. Structured Data Skeleton: All dialogue and descriptions are first defined by a "skeleton" of structured data. This is the source of truth. For an NPC dialogue interaction, this might be a Resource containing fields like:
	* speaker_id: "npc_boris_the_blacksmith"
	* speaker_traits: ["grumpy", "proud_of_work"]
	* player_faction_reputation: 75 (Friendly)
	* active_quest_state: "incomplete"
	* core_dialogue: "You need your sword sharpened? Fine. It'll cost you 20 gold." (This is the critical, handcrafted text containing gameplay information).
2. Prompt Engineering: A dedicated PromptEngineering module takes this structured data and assembles a detailed prompt for the LLM. This prompt provides the LLM with the necessary context and constraints to generate appropriate text.
	* Example Prompt: "You are a game character. Your name is Boris and you are a blacksmith. Your personality is grumpy but you are proud of your work. You are speaking to the player, with whom you have a friendly relationship. The player has not yet completed a quest you gave them. Your essential message is: 'You need your sword sharpened? Fine. It'll cost you 20 gold.' Add one or two sentences of flavorful commentary before this essential message that reflects your personality and the current situation."
3. Asynchronous LLM Generation: The engineered prompt is sent to the local GDLlama node using its run_generate_text function. The game continues to run without interruption while the LLM processes the request in a background thread.30
4. Text Integration: When the GDLlama node emits its generate_text_finished signal, the system receives the generated flavor text (e.g., "Hmph. Back again. I see you're still running around with a dull blade instead of finding that rare ore for me."). The game's UI then combines this with the core dialogue to present the full text to the player.
This "smart pipe" architecture ensures that the game engine retains full control over all logic and critical information. The LLM is treated as a sophisticated natural language processor, a tool for translating the game's rich internal state into varied and personalized prose. This approach harnesses the power of LLMs for narrative enhancement while mitigating the risks associated with their use in interactive systems.

Section 6: Meta-Progression and Data Persistence

This final section details the systems responsible for managing the player's long-term journey and progress. This involves two distinct but related challenges: creating a compelling meta-progression loop that rewards players across multiple runs, and implementing a robust save/load architecture that can handle both the ephemeral state of a single run and the permanent state of the player's overall account.

6.1 Player Account and Meta-Progression Systems

To create a compelling long-term engagement loop, the game will feature a meta-progression system that allows players to unlock new content and options over time. This progress is stored in a master PlayerAccount.tres resource, which is entirely separate from the save data of any individual World Run.
This PlayerAccount resource will serve as the central repository for all of the player's global progress and will track all unlocked content, including:
* Playable Characters: A list of all character archetypes the player has unlocked and can choose from when starting a new run.
* Item Blueprints: Unlocked base items and magical affixes that can be added to the procedural generator's pools, increasing the variety of loot found in future runs.
* World Run Modifiers: Unlocked map modifiers (e.g., "Archipelago," "Volcanic") and faction modifiers (e.g., "Warring Factions") that the player can select to customize their next run.
* Constraint Modifiers: Unlocked options for difficulty and playstyle, such as higher turn limits or different starting conditions.
Progress is driven by a Meta-Currency and the achievement of specific milestones. During a World Run, players can earn this currency by completing quests, defeating powerful enemies, or reaching certain objectives. At the end of a run (whether successful or not), this currency is awarded to their account. Between runs, the player can access a meta-game menu where they can spend this currency to purchase new unlocks from a progression tree. This creates the core meta-game loop: Play a World Run -> Earn Meta-Currency & Achieve Milestones -> End of Run -> Spend Currency on Unlocks -> Start a New, More Varied Run.

6.2 Save/Load Architecture

A robust and clearly defined save/load architecture is essential for a game with this level of complexity. The architecture must distinguish between the two primary types of game state: the temporary state of a run-in-progress and the permanent state of the player's meta-progression. To implement this, the game will use two distinct save files, leveraging Godot's built-in FileAccess and ResourceSaver classes. These tools are strongly preferred over external formats like JSON because of their native ability to serialize and deserialize complex Godot objects and resources, which significantly simplifies the code and reduces the potential for errors.31
* Run-in-Progress Save (run_save.dat):
	* Purpose: This file is used to save the complete state of the player's current World Run. This is the save file that is governed by the "Save Limit" constraint of the run.
	* Data Saved: This file will contain a serialized dictionary holding all the data necessary to perfectly restore a run. This includes:
		* The entire WorldState resource (the seed, all generation parameters, and the full map graph).
		* The complete state of the player's party, including their EntityData resources and all attached component resources (stats, inventory, skills, etc.).
		* The current state of every node on the world map (e.g., which encounters have been cleared, which NPCs have been spoken to).
		* The complete state of all active and completed quests.
	* Serialization Method: The system will use the FileAccess.store_var() method. This function is ideal for this purpose as it uses Godot's built-in serialization engine to handle complex nested data, including dictionaries, arrays, and custom resources, without requiring manual conversion.31
* Persistent Meta-Game Save (meta_save.dat):
	* Purpose: This file stores the player's permanent, long-term progress. It is loaded once when the game starts and is saved only after a World Run has been fully completed or when the player makes changes in the meta-progression menu (e.g., unlocking a new character).
	* Data Saved: This file contains two key pieces of information:
		1. The PlayerAccount.tres resource, which holds all meta-progression unlocks.
		2. The MetaState object, which contains the persistent narrative data (World Facts, Character Fates, etc.).
	* Serialization Method: A combination of ResourceSaver.save() and FileAccess.store_var() will be used. ResourceSaver.save() is perfectly suited for saving the PlayerAccount resource directly.31 The
MetaState dictionary will be saved alongside it in the same file using store_var().
This clear architectural separation of the run state from the meta state is paramount. It prevents data corruption by isolating the high-frequency, potentially volatile run-save from the low-frequency, critical meta-save. This design also clarifies the game's logic. The meta_save.dat is loaded into global singletons at startup and persists for the entire session, while a run_save.dat is only loaded when the player explicitly continues a game in progress. The logic for "ending a run" becomes a critical transaction: the system reads the final state of the run, processes its outcomes to update the in-memory MetaState and PlayerAccount singletons, and then securely writes those updated objects to the meta_save.dat file.

Conclusion and Recommendations

The architectural blueprint detailed in this document provides a comprehensive and technically sound foundation for the development of Project Chimera in Godot 4.5. The design is ambitious, but by adhering to the core pillars of modularity, data-oriented design, and procedural generation, the project's goals of creating a deeply replayable and emergent Turn-Based Strategy RPG are achievable.
Key Architectural Recommendations:
1. Embrace the Hybrid ECS-Resource Model: The proposed hybrid architecture is the single most important technical decision. It provides a clear and scalable separation of data and logic while leveraging the unique strengths of the Godot engine. Strict adherence to this pattern—using Custom Resources for data components and Node-based Systems for logic—will be essential for managing the project's complexity.
2. Prioritize the Universal Entity and Event Bus: The EntityData resource and the EventBus singleton are the two primary enablers of emergent gameplay. All gameplay systems must be designed to operate on the generic EntityData interface and communicate exclusively through the EventBus. This discipline will prevent the creation of hard-coded special cases and allow for the free interaction of modular systems.
3. Develop in Layers: The procedural generation systems should be developed in distinct, independent layers: first, the structural graph generation of the world map; second, the intelligent population of that map by the Narrative Designer; and third, the generation of granular content like characters and items. This layered approach allows for independent iteration and testing, and is key to creating procedural content that feels purposeful rather than random.
4. Constrain the LLM's Role: The integration of a local LLM for dialogue enhancement should be approached with caution. The "smart pipe" architecture, where the game engine provides a highly constrained, data-rich prompt to the LLM for purely cosmetic text generation, is the recommended path. This harnesses the LLM's strength in natural language generation while preventing it from interfering with critical game logic.
5. Separate Run State from Meta State: The save game architecture must maintain a strict separation between the temporary state of a single "World Run" and the permanent state of the player's meta-progression and narrative history. This two-file system is critical for data integrity and reflects the game's dual-loop progression structure.
Final Assessment:
The successful implementation of this design will require a development team that is not only proficient in Godot and GDScript but also deeply understands the principles of data-oriented design and procedural content generation. The most significant challenges will lie not in the implementation of any single system, but in the disciplined orchestration of all systems to work together through abstract, data-driven interfaces. The "Narrative Designer" and "Quest Planner" modules, in particular, represent significant AI and content design challenges that will require substantial iteration and balancing.
By following this blueprint, the development team can build a robust and flexible foundation capable of supporting a truly unique and emergent gameplay experience that fulfills the ambitious vision of Project Chimera.


Works cited


1. Design patterns in Godot · GDQuest, accessed September 13, 2025, https://www.gdquest.com/tutorial/godot/design-patterns/intro-to-design-patterns/(https://www.gdquest.com/tutorial/godot/design-patterns/intro-to-design-patterns/)
2. Resources — Godot Engine (4.4) documentation in English, accessed September 13, 2025, https://docs.godotengine.org/en/4.4/tutorials/scripting/resources.html(https://docs.godotengine.org/en/4.4/tutorials/scripting/resources.html)
3. My GodotCon talk on custom resources got posted :) : r/godot - Reddit, accessed September 13, 2025, https://www.reddit.com/r/godot/comments/1mwh2bo/my_godotcon_talk_on_custom_resources_got_posted/(https://www.reddit.com/r/godot/comments/1mwh2bo/my_godotcon_talk_on_custom_resources_got_posted/)
4. how to build for modularity in Godot 4 - Reddit, accessed September 13, 2025, https://www.reddit.com/r/godot/comments/126w4ag/how_to_build_for_modularity_in_godot_4/(https://www.reddit.com/r/godot/comments/126w4ag/how_to_build_for_modularity_in_godot_4/)
5. csprance/gecs: Godot Entity Component System - GECS - GitHub, accessed September 13, 2025, https://github.com/csprance/gecs/(https://github.com/csprance/gecs/)
6. GECS - Godot Asset Library, accessed September 13, 2025, https://godotengine.org/asset-library/asset/3481(https://godotengine.org/asset-library/asset/3481)
7. Data-oriented design, Object-oriented programming, and GDScript - General - Godot Forum, accessed September 13, 2025, https://forum.godotengine.org/t/data-oriented-design-object-oriented-programming-and-gdscript/98056(https://forum.godotengine.org/t/data-oriented-design-object-oriented-programming-and-gdscript/98056)
8. GDScript ECS 4.x - Gadget, accessed September 13, 2025, https://gadgetgodot.com/u/yihrmc/gdscript-ecs-4x(https://gadgetgodot.com/u/yihrmc/gdscript-ecs-4x)
9. Events Are The Way To Go(dot) – Eric Peterson – GodotCon 2025 - YouTube, accessed September 13, 2025, https://www.youtube.com/watch?v=yB3Wv-Lr7pg(https://www.youtube.com/watch?v=yB3Wv-Lr7pg)
10. Using InputEvent — Godot Engine (4.4) documentation in English, accessed September 13, 2025, https://docs.godotengine.org/en/4.4/tutorials/inputs/inputevent.html(https://docs.godotengine.org/en/4.4/tutorials/inputs/inputevent.html)
11. Ideas on implementing an event-driven custom code system : r/godot - Reddit, accessed September 13, 2025, https://www.reddit.com/r/godot/comments/1br81dq/ideas_on_implementing_an_eventdriven_custom_code/(https://www.reddit.com/r/godot/comments/1br81dq/ideas_on_implementing_an_eventdriven_custom_code/)
12. Procedurally generated biography based on skills and traits in my open world colony sim : r/proceduralgeneration - Reddit, accessed September 13, 2025, https://www.reddit.com/r/proceduralgeneration/comments/1n4v9uu/procedurally_generated_biography_based_on_skills/(https://www.reddit.com/r/proceduralgeneration/comments/1n4v9uu/procedurally_generated_biography_based_on_skills/)
13. Code the Entity-Component pattern in Godot · GDQuest, accessed September 13, 2025, https://www.gdquest.com/tutorial/godot/design-patterns/entity-component-pattern/(https://www.gdquest.com/tutorial/godot/design-patterns/entity-component-pattern/)
14. Procedural Generation in Games - Game-Ace, accessed September 13, 2025, https://game-ace.com/blog/procedural-generation-in-games/(https://game-ace.com/blog/procedural-generation-in-games/)
15. Procedural Content Generation via Generative Artificial Intelligence - arXiv, accessed September 13, 2025, https://arxiv.org/html/2407.09013v1(https://arxiv.org/html/2407.09013v1)
16. What are your thoughts on procedural character generation? : r/gamedesign - Reddit, accessed September 13, 2025, https://www.reddit.com/r/gamedesign/comments/1hoyn4w/what_are_your_thoughts_on_procedural_character/(https://www.reddit.com/r/gamedesign/comments/1hoyn4w/what_are_your_thoughts_on_procedural_character/)
17. Taking Procedural Generation to the Next Level : r/truegaming - Reddit, accessed September 13, 2025, https://www.reddit.com/r/truegaming/comments/5wy86e/taking_procedural_generation_to_the_next_level/(https://www.reddit.com/r/truegaming/comments/5wy86e/taking_procedural_generation_to_the_next_level/)
18. A Graph-Based Approach to Procedural Terrain - Christian Schulte, accessed September 13, 2025, https://chschulte.github.io/teaching/theses/TRITA-ICT-EX-2015:72.pdf(https://chschulte.github.io/teaching/theses/TRITA-ICT-EX-2015:72.pdf)
19. Procedural Map Generation - Cogmind / Grid Sage Games, accessed September 13, 2025, https://www.gridsagegames.com/blog/2014/06/procedural-map-generation/(https://www.gridsagegames.com/blog/2014/06/procedural-map-generation/)
20. Procedural Generation of 3D Maps A Study of Polygon Graph based Map Generation - Yves-Noel Weweler, accessed September 13, 2025, https://yweweler.de/downloads/articles/procedural-generation-of-3d-maps-a-study-of-polygon-graph-based-map-meneration/report-patel10-stanford.pdf(https://yweweler.de/downloads/articles/procedural-generation-of-3d-maps-a-study-of-polygon-graph-based-map-meneration/report-patel10-stanford.pdf)
21. Layered procedural generation for complex world generation : r/godot - Reddit, accessed September 13, 2025, https://www.reddit.com/r/godot/comments/1b4lhp3/layered_procedural_generation_for_complex_world/(https://www.reddit.com/r/godot/comments/1b4lhp3/layered_procedural_generation_for_complex_world/)
22. Architecture of the quest generator system. | Download Scientific ..., accessed September 13, 2025, https://www.researchgate.net/figure/Architecture-of-the-quest-generator-system_fig2_286454232(https://www.researchgate.net/figure/Architecture-of-the-quest-generator-system_fig2_286454232)
23. Procedural generation - Wikipedia, accessed September 13, 2025, https://en.wikipedia.org/wiki/Procedural_generation(https://en.wikipedia.org/wiki/Procedural_generation)
24. Procedural Narrative and How to Make It Coherent, accessed September 13, 2025, https://newtonarrative.com/blog/procedural-narrative-and-how-to-keep-it-coherent/(https://newtonarrative.com/blog/procedural-narrative-and-how-to-keep-it-coherent/)
25. Roguelikes and narrative design with Hades creative director Greg Kasavin - GDC Podcast ep. 16 - Game Developers Conference, accessed September 13, 2025, https://gdconf.com/article/roguelikes-and-narrative-design-with-hades-creative-director-greg-kasavin-gdc-podcast-ep-16/(https://gdconf.com/article/roguelikes-and-narrative-design-with-hades-creative-director-greg-kasavin-gdc-podcast-ep-16/)
26. Very simple and basic Turn-Based Combat mechanic on Godot 4.2 - Reddit, accessed September 13, 2025, https://www.reddit.com/r/godot/comments/18zl1f9/very_simple_and_basic_turnbased_combat_mechanic/(https://www.reddit.com/r/godot/comments/18zl1f9/very_simple_and_basic_turnbased_combat_mechanic/)
27. Party-Based Strategy RPG Combat Script (Godot-4, GDScript) - Programming, accessed September 13, 2025, https://forum.godotengine.org/t/party-based-strategy-rpg-combat-script-godot-4-gdscript/51353(https://forum.godotengine.org/t/party-based-strategy-rpg-combat-script-godot-4-gdscript/51353)
28. Programming a tactical strategy game in Godot 4 - YouTube, accessed September 13, 2025, https://www.youtube.com/watch?v=w6jXgaWHo1s(https://www.youtube.com/watch?v=w6jXgaWHo1s)
29. Rule-based Procedural Generation of Item in Role-playing Game, accessed September 13, 2025, https://ijaseit.insightsociety.org/index.php/ijaseit/article/download/1739/pdf_537/8109(https://ijaseit.insightsociety.org/index.php/ijaseit/article/download/1739/pdf_537/8109)
30. Adriankhl/godot-llm: LLM in Godot - GitHub, accessed September 13, 2025, https://github.com/Adriankhl/godot-llm(https://github.com/Adriankhl/godot-llm)
31. Saving/loading data :: Godot 4 Recipes - KidsCanCode, accessed September 13, 2025, https://kidscancode.org/godot_recipes/4.x/basics/file_io/index.html(https://kidscancode.org/godot_recipes/4.x/basics/file_io/index.html)
32. Saving games — Godot Engine (stable) documentation in English, accessed September 13, 2025, https://docs.godotengine.org/en/stable/tutorials/io/saving_games.html(https://docs.godotengine.org/en/stable/tutorials/io/saving_games.html)
33. Save & Load in Godot 4.4 | Ultimate Guide - YouTube, accessed September 13, 2025, https://www.youtube.com/watch?v=xG2GGniUa5o(https://www.youtube.com/watch?v=xG2GGniUa5o)

